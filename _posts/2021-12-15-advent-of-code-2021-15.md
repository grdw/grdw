---
layout: post
title: "Advent of code 2021: Day 15"
problem_type: aoc2021
problem: 15
complexity: 4
---

### Part 1
I finally get out of the caves, but I have to check which route would involve the least amount of risk. This is when actually Dijkstra comes in to play for real, instead of the thing I mentioned earlier in [Day 12](/2021/12/12/advent-of-code-2021-12.html). The code for part 1, went something like this:

```rust
use std::fs;
use std::cmp::Ordering;
use std::collections::BinaryHeap;

type Grid = Vec<Vec<Node>>;

#[derive(Debug, Clone)]
struct Node(usize, usize);

#[derive(Debug, Clone)]
struct Edge(usize, usize);
type Edges = Vec<Vec<Edge>>;

fn main() {
    let display_string = fs::read_to_string("input")
                            .unwrap_or("".to_string());

    let risk = risk_level(&display_string, 0, 9999);
    println!("The risk level is: {:?}", risk);
}

fn to_grid(input: &str) -> Grid {
    let mut grid: Grid = vec![];
    let mut id = 0;

    for line in input.split_terminator("\n") {
        let mut points = vec![];

        for cha in line.chars() {
            let value = cha.to_digit(10).unwrap() as usize;
            points.push(Node(id, value));
            id += 1;
        }

        grid.push(points);
    }

    grid
}

fn to_graph(input: &str) -> Edges {
    let grid = to_grid(input);
    let size = grid.len();

    let mut edges: Edges = vec![vec![]; size.pow(2)];

    for y in 0..size {
        for x in 0..size {
            let current = &grid[y][x];

            if let Some(row) = grid.get(y + 1) {
                edges[current.0].push(Edge(
                    row[x].0,
                    (current.1 + row[x].1) as usize
                ));
            }

            if let Some(cell) = grid[y].get(x + 1) {
                edges[current.0].push(Edge(
                    cell.0,
                    (current.1 + cell.1) as usize
                ));
            }
        }
    }

    edges
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
struct State {
    cost: usize,
    position: usize,
}

impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        other.cost.cmp(&self.cost)
            .then_with(|| self.position.cmp(&other.position))
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

fn risk_level(input: &str, start: usize, goal: usize) -> Option<usize> {
    let edges = to_graph(input);
    let mut dist: Vec<_> = vec![usize::MAX; edges.len()];
    let mut heap = BinaryHeap::new();

    dist[start] = 0;
    heap.push(State { cost: 0, position: start });

    while let Some(State { cost, position }) = heap.pop() {
        if position == goal { return Some(cost / 2); }
        if cost > dist[position] { continue; }

        for edge in &edges[position] {
            let next = State { cost: cost + edge.1, position: edge.0 };

            if next.cost < dist[next.position] {
                heap.push(next);

                dist[next.position] = next.cost;
            }
        }
    }

    None
}
```

For some stupid reason I had to divide the final cost by 2, and I didn't know why exactly. It got me to the right answer, but it is actually wrong to do so. Which brings me to part 2:

### Part 2
I had no clue what I was doing here. Basically, I extended the grid 5 times, which took me some tries. And I just executed the same algorithm on the same grid, obviously resulting in the wrong number. After checking Reddit, it seemed that you had to include movements to the left and top as well (and I don't know why), to make this fully work. After checking the code from other Dijkstra-people, I took some inspiration from that (let's call it stealing), and I got the correct answer.

The fact is: this puzzle was just not so much fun. You know you have to use Dijkstra, and you know there's some quirk somewhere. Good luck. This was more frustrating, than actually 'fun'. Also, the quirk wasn't in the examples, which makes it just so much more frustrating. "The example works, but the actual input doesn't", is a bit of a classic. Give more examples!
