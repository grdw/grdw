---
layout: post
title: "Project Euler #29: Distinct powers"
euler: 29
complexity: 2
---

{% include euler.html %}

**Introduction**
How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

The first part of this problem is: does 100^100 fit in a Rust integer? It seems like it doesn't, so we must find a smarter way of solving this little mystery. We know the total distinct terms is going to be < 9801, because of the grid size ((100 - 1) * 2). We can start with that and reduce the duplicate terms, but how many duplicates do we get _per row_? We know f.e. 2^6 is the same as 4^3. Other examples:

```
64 can be noted down as:

2*2*2*2*2*2
4*4*4
8*8

1024 can be noted down as:
2*2*2*2*2*2*2*2*2*2 (10 2's)
4*4*4*4*4 (5 4's)
32*32 (2 32's)
```

**The prime factors rabbit hole**
My first train of thought is: we're going to turn 1 to a 100 into their distinct prime factors. I'm going to use the `is_prime` method from ["Largest prime factor"](/2021/10/23/project-euler-3-largest-prime-factor.html) and write a method to determine the prime factors:

```rust
fn prime_factors(mut number: u64) -> Vec<u64> {
    let mut factors: Vec<u64> = vec![];
    let mut factor: u64 = 2;
    let end = (number as f64).sqrt().floor() as u64;

    while number > 1 {
        if is_prime(factor) && number % factor == 0 {
            factors.push(factor);
            number /= factor;
        } else {
            factor += 1;
        }
    }
    factors
}
```

The prime factors of 4 are 2x2, if I were to take the power of 4 from 4, that's 256, or 2^8 in prime factors (those would both be a duplicate). So first up; the code below will generate all prime factors:

```rust
for i in 2..=100 {
    for j in 2..=100 {
        let mut list = prime_factors(i);
        for n in 0..list.len() {
            let mut t = vec![list[n]; j - 1];
            list.append(&mut t);
        }
        list.sort();
        println!("A: {}, B: {}, TOTAL: {:?}", i, j, list);
    }
}
```

The next step would be to push all the vectors into another vector and checking if the previous vector has already passed once before. However, comparing `<Vec>'s` with each other is going to be a big fat pain. Especially when the vector for 100^100 looks like: 200 2's followed by 200 5's. To be a little blunt: this isn't going anywhere. In theory, we could solve it like this, but this is going to be way too complicated. There has to be an easier solution. Perhaps it's: only the perfect numbers will be in here more than once? Perhaps the Wikipedia article on Exponentiation [1] can be of use? In that article they mention some interesting facts which may or may not be of use. One of the things that catches my eye is their power table.

So a couple of things that catch my eye:

```
2^4 = 4^2
2^6 = 4^3 = 8^2
2^8 = 4^4
2^9 = 8^3
2^10 = 4^5
etc.

3^6 = 9^3
3^8 = 9^4
3^10 = 9^5
etc.
```

Assuming the first row of 2^n's will give unique results (and they will), we'll have 99 unique values. The next row, with value 3^n, will also give unique results and won't interfere with the 2^n's and for any prime number they will give unique results. For the number 4, skip, (99 - 2) / 2 = 48 numbers. For the number 6, even though it's a composite, we'll also allow all numbers. For the number 8 we skip the first (99 - 2) / 4 = 24 outcomes. For the number 10 we'll also allow the first 99 digits. Again, thinking about it in this way won't get me anywhere near the actual answer, because I fail to see the pattern.

**Rethinking the prime factors rabbit hole**
Switching back to the prime factors rabbit hole, there's a simple way of comparing those large vectors, casting them to a String of course.

```rust
fn problem_29(max: u64) -> u64 {
    let mut totals: Vec<String> = vec![];
    for a in 2..=max {
        for b in 2..=max {
            let mut factors = prime_factors(a);
            for i in 0..factors.len() {
                let mut n = vec![factors[i]; b as usize - 1];
                factors.append(&mut n)
            }

            let mut string = String::from("");
            for i in &factors {
                string.push_str(&i.to_string());
            }

            if !totals.contains(&string) {
                totals.push(string);
            }
        }
    }
    totals.len() as u64
}

#[test]
fn test_problem_29() {
    assert_eq!(problem_29(5), 15);
    assert_eq!(problem_29(6), 23);
    assert_eq!(problem_29(100), 9276);
}
```

This actually gives me an answer: 9276 unique numbers. This seems to be incorrect, and I might know why that is, it is because we currently don't sort the factors. After some sorting, we get to the correct answer of 9183. It's not the fastest route, but it gives me the correct answer.

**Improving the answer**
After some refactoring I got rid of the sorting and after reading up on how to repeat characters in a string [2], this is the code I end up with:

```rust
fn problem_29(max: u64) -> u64 {
    let mut totals: Vec<String> = vec![];
    for a in 2..=max {
        for b in 2..=max {
            let primes = prime_factors(a);
            let mut string = String::from("");

            for i in 0..primes.len() {
                let sub_string = primes[i]
                    .to_string()
                    .repeat(b as usize);

                string.push_str(&sub_string);
            }

            if !totals.contains(&string) {
                totals.push(string);
            }
        }
    }
    totals.len() as u64
}

#[test]
fn test_problem_29() {
    assert_eq!(problem_29(5), 15);
    assert_eq!(problem_29(6), 23);
    assert_eq!(problem_29(100), 9183);
}
```

The code above is a bit nicer, but it still takes 4 seconds to calculate. The reason why that is, is because 100^100 is denoted as a String containing 200 2's and 200 5's, a 400 character String if you will. This can obviously just become: `2|200|5|200|`; a string denoting the same information, but with a lot less characters. To make that change, we first change the way `prime_factors` work. It needs to return a tuple of unique prime factors and their counts. The next change is to parse that string a little differently using `format!`.

After applying those changes the code still seems very slow which mainly has to do to with `!totals.contains(..)`. This method does a search every loop cycle, which becomes slower and slower once `totals` starts to increase. The simple solution here is to drop it from the code and use `sort()` and `dedup()` at the end of the for-loop, like this:

```rust
fn problem_29(max: u16) -> u16 {
    let mut totals: Vec<String> = vec![];

    for a in 2..=max {
        let primes = prime_factors(a as u8);

        for b in 2..=max {
            let string = primes
                .iter()
                .map(|(n, len)| format!("{}|{}|", n, *len as u16 * b))
                .collect();

            totals.push(string)
        }
    }

    totals.sort();
    totals.dedup();
    totals.len() as u16
}
```

The speed increase here is quite significant; the runtime reduces from 4 seconds to 0.02 seconds. Now that's what I call podracing!

**Sources**

\[1\] [Wikipedia/Exponentiation](https://en.wikipedia.org/wiki/Exponentiation)

\[2\] [Fill string with repeated character](https://users.rust-lang.org/t/fill-string-with-repeated-character/1121)

{% include euler_complexity.html %}
